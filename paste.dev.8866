<?php
/**
 * detect_backdoors.php
 * Recursive scanner to find suspicious PHP/web files in a webroot.
 *
 * Usage:
 *   php detect_backdoors.php           # produce HTML report to stdout
 *   php detect_backdoors.php --plain  # produce plain text report
 *
 * Safety: read-only (no deletion, no modification). Use as root/owner that can read files.
 *
 * Limitations: heuristic-based; false positives possible. Review findings manually.
 */

set_time_limit(0);
ini_set('memory_limit', '1024M');

$opts = getopt("", ["path::", "plain"]);
$root = isset($opts['path']) ? $opts['path'] : (__DIR__);
$plain = isset($opts['plain']) || in_array('--plain', $argv);

// Some configuration
$MAX_FILE_READ = 1024 * 1024; // 1MB per file (to avoid huge memory)
$EXT_WHITELIST = ['php','phtml','inc','tpl','html','htm','js','sh','py']; // files to inspect (text-like)
$IGNORE_DIRS = ['.git', 'node_modules', 'vendor', 'wp-content/cache', 'cache', 'logs', 'tmp', 'uploads']; // skip common noisy dirs

// Signatures & suspicious tokens (regexes)
$signatures = [
    // classic webshell signatures
    '/(eval\(|assert\(|preg_replace\s*\(\s*.*\/e.*\)|create_function\s*\(|system\s*\(|shell_exec\s*\(|passthru\s*\(|proc_open\s*\(|popen\s*\(|pcntl_exec\s*\(|exec\s*\(|`.+`)/i',
    '/base64_decode\s*\(/i',
    '/gzinflate\s*\(|gzuncompress\s*\(|gzdecode\s*\(/i',
    '/str_rot13\s*\(|strrev\s*\(|pack\s*\(|unpack\s*\(|hex2bin\s*\(/i',
    '/\$GLOBALS\[[\'"]?[_A-Za-z0-9]+[\'"]?\]/i',
    '/\$_(GET|POST|REQUEST|COOKIE)\[.*\]/i',
    '/preg_replace\s*\(\s*[\'"].+[\'"],\s*[\'"].+[\'"],\s*\$_/i', // suspicious preg_replace usage
    '/(eval\(\s*base64_decode|base64_decode\(\s*@?file_get_contents\(|file_get_contents\(\s*@?["\']php:\/\/input["\']\s*\))/i',
    '/(assert\(|assert\(|create_function\()/i',
    // short suspicious words
    '/(backdoor|webshell|c99|r57|b374k|weevely|reb25|b374k)/i',
];

// Heuristic tokens that increase suspicion score
$tokens = [
    'base64_decode' => 6,
    'eval(' => 8,
    'assert(' => 7,
    'preg_replace' => 4,
    'gzinflate' => 6,
    'gzuncompress' => 6,
    'system(' => 9,
    'shell_exec' => 9,
    'exec(' => 8,
    'passthru' => 9,
    'popen(' => 8,
    'proc_open' => 9,
    'file_get_contents("php://input' => 8,
    'curl_exec' => 5,
    'fopen("php://input' => 7,
    'unserialize(' => 6,
    'create_function' => 6,
    'str_rot13' => 4,
    'hex2bin' => 4,
    'pack(' => 4,
    'pack(' => 4,
];

$results = [];
$now = time();

function is_binary_string($str) {
    // heuristic: if many zero bytes or non-printable proportion > threshold
    $len = strlen($str);
    if ($len === 0) return false;
    $nonprint = 0;
    for ($i=0;$i<$len && $i<2000;$i++){
        $c = ord($str[$i]);
        if ($c === 0) return true;
        if ($c < 9 || ($c > 13 && $c < 32) || $c > 126) $nonprint++;
    }
    return ($nonprint / min($len,2000)) > 0.3;
}

function get_shannon_entropy($str) {
    if ($str === '') return 0;
    $h = 0.0;
    $len = strlen($str);
    $freq = array_count_values(str_split($str));
    foreach ($freq as $c => $count) {
        $p = $count / $len;
        $h -= $p * log($p, 2);
    }
    return $h;
}

function file_preview($path, $n=10) {
    $fp = @fopen($path, 'r');
    if (!$fp) return '';
    $out = '';
    $i=0;
    while (!feof($fp) && $i < $n) {
        $line = fgets($fp);
        if ($line === false) break;
        $out .= htmlspecialchars($line);
        $i++;
    }
    fclose($fp);
    return $out;
}

// sanitize path for display
function short_path($path, $root) {
    $r = rtrim(realpath($root), DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;
    $p = realpath($path);
    if ($p === false) return $path;
    if (strpos($p, $r) === 0) return substr($p, strlen($r));
    return $p;
}

function should_inspect_file($file, $ext_whitelist) {
    $ext = strtolower(pathinfo($file, PATHINFO_EXTENSION));
    if (in_array($ext, $ext_whitelist)) return true;
    // also inspect files with no ext but are text and contain '<?'
    $content = @file_get_contents($file, false, null, 0, 256);
    if ($content !== false && strpos($content, '<?') !== false) return true;
    return false;
}

function match_signatures($content, $signatures) {
    $matches = [];
    foreach ($signatures as $re) {
        if (preg_match($re, $content, $m)) {
            $matches[] = ['regex'=>$re, 'match'=>$m[0]];
        }
    }
    return $matches;
}

function heuristic_score($content, $tokens) {
    $score = 0;
    $lower = strtolower($content);
    foreach ($tokens as $tok => $weight) {
        if (strpos($lower, strtolower($tok)) !== false) {
            $count = substr_count($lower, strtolower($tok));
            $score += $weight * min(5, $count); // cap per token
        }
    }
    // long single-line obfuscated code (e.g., thousands of chars no newline)
    if (strlen($content) > 5000 && substr_count($content, "\n") < 5) {
        $score += 10;
    }
    return $score;
}

function scan_directory($root, $opts) {
    global $results, $MAX_FILE_READ, $EXT_WHITELIST, $IGNORE_DIRS, $signatures, $tokens, $now;
    $rii = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($root,
        FilesystemIterator::SKIP_DOTS | FilesystemIterator::FOLLOW_SYMLINKS), RecursiveIteratorIterator::SELF_FIRST);

    foreach ($rii as $fileInfo) {
        $path = $fileInfo->getPathname();

        // skip directories in ignore list
        foreach ($IGNORE_DIRS as $ig) {
            if (strpos($path, DIRECTORY_SEPARATOR . $ig . DIRECTORY_SEPARATOR) !== false) continue 2;
        }
        // skip unreadable
        if (!$fileInfo->isFile() || !$fileInfo->isReadable()) continue;

        // inspect likely files only
        if (!should_inspect_file($path, $EXT_WHITELIST)) continue;

        // read head of file (up to MAX_FILE_READ)
        $size = $fileInfo->getSize();
        $read_len = min($size, $MAX_FILE_READ);
        $content = @file_get_contents($path, false, null, 0, $read_len);
        if ($content === false) continue;

        // skip binaries
        if (is_binary_string($content)) continue;

        $rel = short_path($path, $opts['root']);
        $mtime = $fileInfo->getMTime();
        $owner = @posix_getpwuid(@fileowner($path));
        $ownerName = $owner ? $owner['name'] : fileowner($path);

        $matches = match_signatures($content, $signatures);
        $score = heuristic_score($content, $tokens);

        // entropy check for large base64/blobs
        $entropy = get_shannon_entropy($content);
        if ($entropy > 4.2) $score += 6;
        if ($entropy > 4.8) $score += 6;

        // long base64 strings detection
        if (preg_match('/[A-Za-z0-9\/+\=]{200,}/', $content, $mb)) {
            $score += 8;
        }

        // suspicious file metadata: recently modified (last 30 days)
        $age_days = ($now - $mtime) / 86400;
        if ($age_days < 30) $score += 3;

        // file permissions writable by group/other
        $perms = fileperms($path);
        if ($perms !== false) {
            $is_world_writable = ($perms & 0x0002) ? true : false;
            if ($is_world_writable) $score += 5;
        }

        // record if any suspicion
        if (!empty($matches) || $score >= 8) {
            $results[] = [
                'path' => $path,
                'rel' => $rel,
                'size' => $size,
                'mtime' => date('Y-m-d H:i:s', $mtime),
                'age_days' => round($age_days,1),
                'owner' => $ownerName,
                'score' => $score,
                'matches' => $matches,
                'entropy' => round($entropy,3),
                'preview' => file_preview($path, 12),
                'perms' => $perms ? substr(sprintf('%o', $perms), -4) : '----'
            ];
        }
    }
}

// run scan
scan_directory($root, ['root'=>$root]);

// sort results by score desc then mtime
usort($results, function($a,$b){
    if ($a['score'] === $b['score']) return strcmp($b['mtime'], $a['mtime']);
    return $b['score'] - $a['score'];
});

// Output
if ($plain) {
    echo "Backdoor Scan Report for: {$root}\n";
    echo str_repeat('=', 60) . "\n";
    foreach ($results as $r) {
        echo "Path: {$r['rel']}\n";
        echo "  Score: {$r['score']}, Size: {$r['size']} bytes, Modified: {$r['mtime']}, Owner: {$r['owner']}, Perms: {$r['perms']}\n";
        if (!empty($r['matches'])) {
            echo "  Matches:\n";
            foreach ($r['matches'] as $m) {
                echo "    - {$m['regex']} => " . trim(substr($m['match'],0,120)) . "\n";
            }
        }
        echo "  Entropy: {$r['entropy']}, Age(days): {$r['age_days']}\n";
        echo "  Preview:\n";
        echo "-----\n";
        echo html_entity_decode($r['preview']) . "\n";
        echo "-----\n\n";
    }
    echo "Summary: " . count($results) . " suspicious files found.\n";
    exit(0);
}

// HTML output
?>
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Backdoor Scan Report</title>
<style>
body{font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; padding:18px; background:#f8f9fb;}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #ddd;padding:8px;text-align:left;vertical-align:top}
th{background:#0b5; color:#fff}
tr.high td{background:#ffecec}
.preview{font-family:monospace;background:#111;color:#e6e6e6;padding:8px;overflow:auto;max-height:200px}
.badge{display:inline-block;padding:4px 8px;border-radius:6px;background:#e74c3c;color:#fff;font-weight:600}
.ok{background:#2ecc71}
.small{font-size:0.9em;color:#666}
</style>
</head>
<body>
<h1>Backdoor Scan Report</h1>
<p class="small">Root scanned: <strong><?=htmlspecialchars($root)?></strong> â€” <?=count($results)?> suspicious files found.</p>
<table>
<thead>
<tr><th>Score</th><th>Path (relative)</th><th>Details</th><th>Preview</th></tr>
</thead>
<tbody>
<?php foreach ($results as $r): ?>
    <?php $rowclass = $r['score'] >= 18 ? 'high' : ''; ?>
    <tr class="<?= $rowclass ?>">
        <td>
            <div class="badge"><?= $r['score'] ?></div>
            <div class="small">entropy <?= $r['entropy'] ?><br/>age <?= $r['age_days'] ?>d</div>
        </td>
        <td>
            <strong><?= htmlspecialchars($r['rel']) ?></strong>
            <div class="small">size <?= $r['size'] ?> bytes â€” modified <?= $r['mtime'] ?> â€” owner <?= htmlspecialchars($r['owner']) ?> â€” perms <?= htmlspecialchars($r['perms']) ?></div>
        </td>
        <td>
            <?php if (!empty($r['matches'])): ?>
                <div><strong>Signature matches:</strong></div>
                <ul>
                <?php foreach ($r['matches'] as $m): ?>
                    <li><code><?= htmlspecialchars($m['match']) ?></code> <span class="small">(<?=htmlspecialchars($m['regex'])?>)</span></li>
                <?php endforeach; ?>
                </ul>
            <?php else: ?>
                <div class="small">No direct signature; flagged by heuristic score.</div>
            <?php endif; ?>
            <div class="small">Hint: review file with an editor, compare with clean backups, check git history.</div>
        </td>
        <td><div class="preview"><?= $r['preview'] ?></div></td>
    </tr>
<?php endforeach; ?>
</tbody>
</table>

<footer style="margin-top:20px">
<h3>How to act (short)</h3>
<ul>
<li><strong>Do not delete files immediately.</strong> Quarantine by moving to a safe directory (outside webroot) or set restrictive permissions (chmod 600) after backing up.</li>
<li>Check file owner and modification time. If owner is webserver user (www-data, nobody), that may indicate server-side write access.</li>
<li>Check server logs for suspicious requests near the file's mtime.</li>
<li>Restore from known clean backup or git history when possible.</li>
<li>After cleanup, rotate credentials (FTP, admin panels, DB) and audit for webserver vulnerabilities, plugins, weak passwords.</li>
</ul>
<p class="small">This tool is heuristic-only. It will not find every backdoor (especially ones that are binary, kernel-level, or injected in memory). For high-risk systems, consider professional incident response.</p>
</footer>
</body>
</html>
